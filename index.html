<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Interior-Point Fracturing for Various Shapes</title>
    <style>
        body {
            margin: 0;
            background: #333;
        }

        canvas {
            display: block;
            margin: auto;
            background: #fff;
        }

        #controls {
            text-align: center;
            margin: 10px;
        }
    </style>
</head>

<body>
    <div id="controls">
        <label for="shapeSelect">Select Shape: </label>
        <select id="shapeSelect">
            <option value="rectangle">Rectangle</option>
            <option value="circle">Circle</option>
            <option value="star">Star</option>
            <option value="heart">Heart</option>
        </select>
        <button id="fractureButton">Fracture!</button>
    </div>
    <canvas id="canvas" width="800" height="600"></canvas>
    <script>
        // --- Utility functions ---

        // Returns a random pastel-ish color.
        function getRandomColor() {
            const r = Math.floor(Math.random() * 200) + 55;
            const g = Math.floor(Math.random() * 200) + 55;
            const b = Math.floor(Math.random() * 200) + 55;
            return `rgb(${r},${g},${b})`;
        }

        // Draws a polygon (given as an array of {x, y} points) on the canvas.
        function drawPolygon(ctx, polygon, fillColor, strokeColor) {
            if (polygon.length === 0) return;
            ctx.beginPath();
            ctx.moveTo(polygon[0].x, polygon[0].y);
            for (let i = 1; i < polygon.length; i++) {
                ctx.lineTo(polygon[i].x, polygon[i].y);
            }
            ctx.closePath();
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.strokeStyle = strokeColor;
            ctx.stroke();
        }

        // Point-in-polygon using the ray-casting algorithm.
        function pointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                const intersect = ((yi > point.y) !== (yj > point.y)) &&
                    (point.x < (xj - xi) * (point.y - yi) / ((yj - yi) || 1e-10) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // Compute the bounding box of a polygon.
        function getBoundingBox(polygon) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            polygon.forEach(pt => {
                if (pt.x < minX) minX = pt.x;
                if (pt.y < minY) minY = pt.y;
                if (pt.x > maxX) maxX = pt.x;
                if (pt.y > maxY) maxY = pt.y;
            });
            return { left: minX, top: minY, right: maxX, bottom: maxY };
        }

        // Returns a random point inside the given shape (using rejection sampling).
        function randomInteriorPoint(shape) {
            const bbox = getBoundingBox(shape.vertices);
            let pt;
            do {
                pt = {
                    x: bbox.left + Math.random() * (bbox.right - bbox.left),
                    y: bbox.top + Math.random() * (bbox.bottom - bbox.top)
                };
            } while (!pointInPolygon(pt, shape.vertices));
            return pt;
        }

        // --- Intersection functions for polygons ---

        // Given a ray starting at point P with angle (in radians),
        // compute its intersection with all edges of the polygon.
        // Returns the closest intersection (if any) along with the edge index and
        // a parameter (u) showing where on the edge the intersection occurred.
        function computeRayIntersectionPolygon(P, angle, shape) {
            const dx = Math.cos(angle);
            const dy = Math.sin(angle);
            let intersections = [];
            const vertices = shape.vertices;
            const n = vertices.length;
            for (let i = 0; i < n; i++) {
                const A = vertices[i];
                const B = vertices[(i + 1) % n];
                const R = { x: B.x - A.x, y: B.y - A.y };
                const denom = dx * R.y - dy * R.x;
                if (Math.abs(denom) < 1e-6) continue; // Parallel or nearly so.
                const t = ((A.x - P.x) * R.y - (A.y - P.y) * R.x) / denom;
                const u = ((A.x - P.x) * dy - (A.y - P.y) * dx) / denom;
                if (t > 1e-6 && u >= 0 && u <= 1) {
                    const point = { x: P.x + t * dx, y: P.y + t * dy };
                    intersections.push({ t, point, edgeIndex: i, u });
                }
            }
            if (intersections.length === 0) return null;
            intersections.sort((a, b) => a.t - b.t);
            return intersections[0];
        }

        // Given two intersection objects (each with an edge index and a position on the edge),
        // return an array of the polygonâ€™s vertices between them.
        // (This simple version assumes the polygon is convex.)
        function getBoundarySegment(intersect1, intersect2, shape) {
            const vertices = shape.vertices;
            const n = vertices.length;
            let segment = [];
            const startEdge = intersect1.edgeIndex;
            const endEdge = intersect2.edgeIndex;
            // If both intersections occur on the same edge, no vertices lie between.
            if (startEdge === endEdge) return segment;
            let i = (startEdge + 1) % n;
            while (i !== (endEdge + 1) % n) {
                segment.push(vertices[i]);
                i = (i + 1) % n;
            }
            return segment;
        }

        // --- Shape creation functions ---
        // Define shapes by returning an object with a "vertices" array.

        // Rectangle.
        function createRectangle(x, y, width, height) {
            return {
                vertices: [
                    { x: x, y: y },
                    { x: x + width, y: y },
                    { x: x + width, y: y + height },
                    { x: x, y: y + height }
                ]
            };
        }

        // Circle approximated as a polygon.
        function createCircle(center, radius, numSides) {
            let vertices = [];
            for (let i = 0; i < numSides; i++) {
                let angle = (i / numSides) * 2 * Math.PI;
                vertices.push({
                    x: center.x + radius * Math.cos(angle),
                    y: center.y + radius * Math.sin(angle)
                });
            }
            return { vertices: vertices };
        }

        // Star shape with alternating outer and inner radii.
        function createStar(center, outerRadius, innerRadius, numPoints) {
            let vertices = [];
            let totalPoints = numPoints * 2;
            let angleStep = (2 * Math.PI) / totalPoints;
            for (let i = 0; i < totalPoints; i++) {
                let angle = i * angleStep;
                let r = (i % 2 === 0) ? outerRadius : innerRadius;
                vertices.push({
                    x: center.x + r * Math.cos(angle),
                    y: center.y + r * Math.sin(angle)
                });
            }
            return { vertices: vertices };
        }

        // Heart shape generated from a parametric equation.
        function createHeart(center, scale, numPoints) {
            let vertices = [];
            for (let i = 0; i < numPoints; i++) {
                let t = (i / numPoints) * 2 * Math.PI;
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                vertices.push({
                    x: center.x + scale * x,
                    y: center.y - scale * y  // Flip y for canvas coordinates.
                });
            }
            return { vertices: vertices };
        }

        // --- Fracturing function for a polygon ---
        // This function picks a random interior point and 4 rays,
        // then uses the intersection points (and the boundary in between)
        // to divide the shape into 4 pieces.
        function fracturePolygon(shape) {
            const P = randomInteriorPoint(shape);
            // Generate 4 random angles.
            let angles = [];
            for (let i = 0; i < 4; i++) {
                angles.push(Math.random() * 2 * Math.PI);
            }
            angles.sort((a, b) => a - b);

            let intersections = [];
            for (let angle of angles) {
                const inter = computeRayIntersectionPolygon(P, angle, shape);
                if (inter) {
                    inter.angle = angle;
                    intersections.push(inter);
                }
            }
            if (intersections.length < 4) return [];

            let pieces = [];
            for (let i = 0; i < 4; i++) {
                let curr = intersections[i];
                let next = intersections[(i + 1) % 4];
                let boundarySegment = getBoundarySegment(curr, next, shape);
                let poly = [];
                poly.push(P);
                poly.push(curr.point);
                boundarySegment.forEach(pt => poly.push(pt));
                poly.push(next.point);
                pieces.push(poly);
            }
            return pieces;
        }

        // --- Main drawing routine ---
        function main() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Choose a shape based on the dropdown selection.
            const shapeSelect = document.getElementById('shapeSelect');
            const shapeType = shapeSelect.value;
            let shape;
            switch (shapeType) {
                case "rectangle":
                    shape = createRectangle(100, 100, 600, 400);
                    break;
                case "circle":
                    shape = createCircle({ x: 400, y: 300 }, 200, 50);
                    break;
                case "star":
                    shape = createStar({ x: 400, y: 300 }, 250, 100, 5);
                    break;
                case "heart":
                    shape = createHeart({ x: 400, y: 300 }, 10, 200);
                    break;
                default:
                    shape = createRectangle(100, 100, 600, 400);
            }

            // Draw the original shape boundary.
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#000";
            drawPolygon(ctx, shape.vertices, "rgba(0,0,0,0)", "#000");

            // Fracture the shape using our interior-point method.
            const pieces = fracturePolygon(shape);
            pieces.forEach(piece => {
                drawPolygon(ctx, piece, getRandomColor(), "#000");
            });
        }

        // Run when the page loads and when the button is clicked.
        window.onload = function () {
            main();
            document.getElementById('fractureButton').addEventListener('click', main);
        };
    </script>
</body>

</html>