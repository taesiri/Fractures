<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Interactive Fracturing with Physics</title>
    <style>
        body {
            margin: 0;
            background: #333;
        }

        canvas {
            display: block;
            margin: auto;
            background: #fff;
        }

        #controls {
            text-align: center;
            margin: 10px;
            color: #fff;
        }

        #controls label,
        #controls select,
        #controls button {
            font-size: 16px;
        }
    </style>
    <!-- Include Matter.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>

<body>
    <div id="controls">
        <label for="shapeSelect">Select Shape: </label>
        <select id="shapeSelect">
            <option value="rectangle">Rectangle</option>
            <option value="circle">Circle</option>
            <option value="star">Star</option>
            <option value="heart">Heart</option>
        </select>
        <button id="fractureButton">Fracture!</button>
        <br><br>
        <label for="paddingSlider">Padding: </label>
        <input type="range" id="paddingSlider" min="0" max="50" value="10">
        <span id="paddingValue">10</span> px
    </div>
    <canvas id="canvas" width="800" height="600"></canvas>
    <script>
        // --- Matter.js Aliases ---
        const Engine = Matter.Engine,
            World = Matter.World,
            Bodies = Matter.Bodies,
            Body = Matter.Body,
            Composite = Matter.Composite,
            Mouse = Matter.Mouse,
            MouseConstraint = Matter.MouseConstraint;

        // --- Create the Matter.js engine and world ---
        let engine = Engine.create();
        let world = engine.world;

        // --- Get canvas and context ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // --- Setup Mouse Constraint for interactivity ---
        let mouse = Mouse.create(canvas);
        let mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: { visible: false }
            }
        });
        World.add(world, mouseConstraint);

        // --- Create a ground so pieces donâ€™t fall off ---
        let ground = Bodies.rectangle(400, 610, 810, 60, { isStatic: true });
        World.add(world, ground);

        // --- Global storage for our fractured piece bodies ---
        let pieceBodies = [];

        // --- Utility Functions ---
        // Returns a random pastel-ish color.
        function getRandomColor() {
            const r = Math.floor(Math.random() * 200) + 55;
            const g = Math.floor(Math.random() * 200) + 55;
            const b = Math.floor(Math.random() * 200) + 55;
            return `rgb(${r},${g},${b})`;
        }

        // Computes the centroid (average of vertices) of a polygon.
        function computeCentroid(polygon) {
            let cx = 0, cy = 0;
            polygon.forEach(pt => {
                cx += pt.x;
                cy += pt.y;
            });
            return { x: cx / polygon.length, y: cy / polygon.length };
        }

        // Shrinks (insets) a polygon by moving each vertex toward the centroid.
        // 'padding' is in pixels.
        function shrinkPolygon(polygon, padding) {
            let centroid = computeCentroid(polygon);
            // Compute average distance from centroid.
            let avgDist = 0;
            polygon.forEach(pt => {
                avgDist += Math.hypot(pt.x - centroid.x, pt.y - centroid.y);
            });
            avgDist /= polygon.length;
            // Clamp factor between 0 and 1.
            let factor = Math.max(0, 1 - (padding / avgDist));
            return polygon.map(pt => ({
                x: centroid.x + (pt.x - centroid.x) * factor,
                y: centroid.y + (pt.y - centroid.y) * factor
            }));
        }

        // Standard ray-casting point-in-polygon test.
        function pointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                const intersect = ((yi > point.y) !== (yj > point.y)) &&
                    (point.x < (xj - xi) * (point.y - yi) / ((yj - yi) || 1e-10) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // Returns the bounding box of a polygon.
        function getBoundingBox(polygon) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            polygon.forEach(pt => {
                if (pt.x < minX) minX = pt.x;
                if (pt.y < minY) minY = pt.y;
                if (pt.x > maxX) maxX = pt.x;
                if (pt.y > maxY) maxY = pt.y;
            });
            return { left: minX, top: minY, right: maxX, bottom: maxY };
        }

        // Returns a random point inside the given shape (using rejection sampling).
        function randomInteriorPoint(shape) {
            const bbox = getBoundingBox(shape.vertices);
            let pt;
            do {
                pt = {
                    x: bbox.left + Math.random() * (bbox.right - bbox.left),
                    y: bbox.top + Math.random() * (bbox.bottom - bbox.top)
                };
            } while (!pointInPolygon(pt, shape.vertices));
            return pt;
        }

        // Given a ray from point P at angle (in radians) and a polygon,
        // compute its intersection with each edge. Returns the closest intersection.
        function computeRayIntersectionPolygon(P, angle, shape) {
            const dx = Math.cos(angle);
            const dy = Math.sin(angle);
            let intersections = [];
            const vertices = shape.vertices;
            const n = vertices.length;
            for (let i = 0; i < n; i++) {
                const A = vertices[i];
                const B = vertices[(i + 1) % n];
                const R = { x: B.x - A.x, y: B.y - A.y };
                const denom = dx * R.y - dy * R.x;
                if (Math.abs(denom) < 1e-6) continue; // Parallel.
                const t = ((A.x - P.x) * R.y - (A.y - P.y) * R.x) / denom;
                const u = ((A.x - P.x) * dy - (A.y - P.y) * dx) / denom;
                if (t > 1e-6 && u >= 0 && u <= 1) {
                    const point = { x: P.x + t * dx, y: P.y + t * dy };
                    intersections.push({ t, point, edgeIndex: i, u });
                }
            }
            if (intersections.length === 0) return null;
            intersections.sort((a, b) => a.t - b.t);
            return intersections[0];
        }

        // Given two intersection objects, return the polygon vertices along the boundary between them.
        // (This version works best when the shape is convex or star-shaped.)
        function getBoundarySegment(intersect1, intersect2, shape) {
            const vertices = shape.vertices;
            const n = vertices.length;
            let segment = [];
            const startEdge = intersect1.edgeIndex;
            const endEdge = intersect2.edgeIndex;
            if (startEdge === endEdge) return segment;
            let i = (startEdge + 1) % n;
            while (i !== (endEdge + 1) % n) {
                segment.push(vertices[i]);
                i = (i + 1) % n;
            }
            return segment;
        }

        // --- Shape Creation Functions ---
        // Each shape is represented as an object with a "vertices" array.

        function createRectangle(x, y, width, height) {
            return {
                vertices: [
                    { x: x, y: y },
                    { x: x + width, y: y },
                    { x: x + width, y: y + height },
                    { x: x, y: y + height }
                ]
            };
        }

        function createCircle(center, radius, numSides) {
            let vertices = [];
            for (let i = 0; i < numSides; i++) {
                let angle = (i / numSides) * 2 * Math.PI;
                vertices.push({
                    x: center.x + radius * Math.cos(angle),
                    y: center.y + radius * Math.sin(angle)
                });
            }
            return { vertices: vertices };
        }

        function createStar(center, outerRadius, innerRadius, numPoints) {
            let vertices = [];
            let totalPoints = numPoints * 2;
            let angleStep = (2 * Math.PI) / totalPoints;
            for (let i = 0; i < totalPoints; i++) {
                let angle = i * angleStep;
                let r = (i % 2 === 0) ? outerRadius : innerRadius;
                vertices.push({
                    x: center.x + r * Math.cos(angle),
                    y: center.y + r * Math.sin(angle)
                });
            }
            return { vertices: vertices };
        }

        function createHeart(center, scale, numPoints) {
            let vertices = [];
            for (let i = 0; i < numPoints; i++) {
                let t = (i / numPoints) * 2 * Math.PI;
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                vertices.push({
                    x: center.x + scale * x,
                    y: center.y - scale * y  // Flip y for canvas coordinates.
                });
            }
            return { vertices: vertices };
        }

        // --- Fracturing Function ---
        // Uses an interior point and 4 rays to fracture a shape into 4 pieces.
        function fracturePolygon(shape) {
            const P = randomInteriorPoint(shape);
            // Generate 4 random angles and sort them.
            let angles = [];
            for (let i = 0; i < 4; i++) {
                angles.push(Math.random() * 2 * Math.PI);
            }
            angles.sort((a, b) => a - b);

            let intersections = [];
            for (let angle of angles) {
                const inter = computeRayIntersectionPolygon(P, angle, shape);
                if (inter) {
                    inter.angle = angle;
                    intersections.push(inter);
                }
            }
            if (intersections.length < 4) return [];

            let pieces = [];
            for (let i = 0; i < 4; i++) {
                let curr = intersections[i];
                let next = intersections[(i + 1) % 4];
                let boundarySegment = getBoundarySegment(curr, next, shape);
                let poly = [];
                poly.push(P);
                poly.push(curr.point);
                boundarySegment.forEach(pt => poly.push(pt));
                poly.push(next.point);
                pieces.push(poly);
            }
            return pieces;
        }

        // --- Create Physics Bodies from Fractured Pieces ---
        function createFracturedBodies() {
            // Remove any existing piece bodies from the world.
            pieceBodies.forEach(body => {
                World.remove(world, body);
            });
            pieceBodies = [];

            // Choose the shape.
            const shapeSelect = document.getElementById('shapeSelect');
            const shapeType = shapeSelect.value;
            let shape;
            switch (shapeType) {
                case "rectangle":
                    shape = createRectangle(100, 100, 600, 400);
                    break;
                case "circle":
                    shape = createCircle({ x: 400, y: 300 }, 200, 50);
                    break;
                case "star":
                    shape = createStar({ x: 400, y: 300 }, 250, 100, 5);
                    break;
                case "heart":
                    shape = createHeart({ x: 400, y: 300 }, 10, 200);
                    break;
                default:
                    shape = createRectangle(100, 100, 600, 400);
            }

            // Get padding from the slider.
            const paddingSlider = document.getElementById('paddingSlider');
            const padding = Number(paddingSlider.value);
            document.getElementById('paddingValue').textContent = padding;

            // Fracture the shape.
            let pieces = fracturePolygon(shape);

            // For each fractured piece, create a padded (inset) version and then a Matter body.
            pieces.forEach(piece => {
                let paddedPiece = shrinkPolygon(piece, padding);
                let centroid = computeCentroid(paddedPiece);
                // Transform vertices relative to the centroid.
                let relativeVertices = paddedPiece.map(v => ({ x: v.x - centroid.x, y: v.y - centroid.y }));
                // Create a physics body from the vertices.
                let body = Bodies.fromVertices(centroid.x, centroid.y, [relativeVertices],
                    { restitution: 0.5, friction: 0.1, density: 0.001 },
                    true);
                // Assign a custom color for rendering.
                body.customColor = getRandomColor();
                pieceBodies.push(body);
                World.add(world, body);
            });
        }

        // --- Rendering Loop ---
        function update() {
            Engine.update(engine, 1000 / 60);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw each fractured piece (using body.vertices provided by Matter.js).
            pieceBodies.forEach(body => {
                ctx.beginPath();
                let verts = body.vertices;
                ctx.moveTo(verts[0].x, verts[0].y);
                for (let i = 1; i < verts.length; i++) {
                    ctx.lineTo(verts[i].x, verts[i].y);
                }
                ctx.closePath();
                ctx.fillStyle = body.customColor || '#ccc';
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.stroke();
            });

            // (Optional) Draw the ground.
            ctx.beginPath();
            let gVerts = ground.vertices;
            ctx.moveTo(gVerts[0].x, gVerts[0].y);
            for (let i = 1; i < gVerts.length; i++) {
                ctx.lineTo(gVerts[i].x, gVerts[i].y);
            }
            ctx.closePath();
            ctx.fillStyle = "#888";
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.stroke();

            requestAnimationFrame(update);
        }

        // --- Event Listeners ---
        document.getElementById('fractureButton').addEventListener('click', createFracturedBodies);
        // Optionally re-run fracturing when the padding slider changes.
        document.getElementById('paddingSlider').addEventListener('input', createFracturedBodies);
        document.getElementById('shapeSelect').addEventListener('change', createFracturedBodies);

        // Start the simulation loop.
        createFracturedBodies();
        update();
    </script>
</body>

</html>