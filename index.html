<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Interior-Point Fracturing with Adjustable Padding</title>
    <style>
        body {
            margin: 0;
            background: #333;
        }

        canvas {
            display: block;
            margin: auto;
            background: #fff;
        }

        #controls {
            text-align: center;
            margin: 10px;
            color: #fff;
        }

        #controls label,
        #controls select,
        #controls button {
            font-size: 16px;
        }
    </style>
</head>

<body>
    <div id="controls">
        <label for="shapeSelect">Select Shape: </label>
        <select id="shapeSelect">
            <option value="rectangle">Rectangle</option>
            <option value="circle">Circle</option>
            <option value="star">Star</option>
            <option value="heart">Heart</option>
        </select>
        <button id="fractureButton">Fracture!</button>
        <br><br>
        <label for="paddingSlider">Padding: </label>
        <input type="range" id="paddingSlider" min="0" max="50" value="10">
        <span id="paddingValue">10</span> px
    </div>
    <canvas id="canvas" width="800" height="600"></canvas>
    <script>
        // --- Global variables ---
        let currentShape = null;
        let currentPieces = [];

        // --- Utility functions ---
        // Returns a random pastel-ish color.
        function getRandomColor() {
            const r = Math.floor(Math.random() * 200) + 55;
            const g = Math.floor(Math.random() * 200) + 55;
            const b = Math.floor(Math.random() * 200) + 55;
            return `rgb(${r},${g},${b})`;
        }

        // Draws a polygon (given as an array of {x, y} points) on the canvas.
        function drawPolygon(ctx, polygon, fillColor, strokeColor) {
            if (polygon.length === 0) return;
            ctx.beginPath();
            ctx.moveTo(polygon[0].x, polygon[0].y);
            for (let i = 1; i < polygon.length; i++) {
                ctx.lineTo(polygon[i].x, polygon[i].y);
            }
            ctx.closePath();
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.strokeStyle = strokeColor;
            ctx.stroke();
        }

        // --- Helper for "padding" (insetting) a polygon ---
        // This function computes the centroid of the polygon and then moves each vertex
        // toward the centroid by a fraction determined by the 'padding' value.
        function shrinkPolygon(polygon, padding) {
            // Compute centroid.
            let cx = 0, cy = 0;
            polygon.forEach(pt => {
                cx += pt.x;
                cy += pt.y;
            });
            cx /= polygon.length;
            cy /= polygon.length;

            // Compute average distance from the centroid.
            let avgDist = 0;
            polygon.forEach(pt => {
                avgDist += Math.hypot(pt.x - cx, pt.y - cy);
            });
            avgDist /= polygon.length;

            // Determine a shrink factor.
            // If padding is too large relative to the average distance, factor clamps to 0.
            let factor = Math.max(0, 1 - (padding / avgDist));

            // Return the shrunken polygon.
            return polygon.map(pt => ({
                x: cx + (pt.x - cx) * factor,
                y: cy + (pt.y - cy) * factor
            }));
        }

        // --- Point-in-polygon (ray-casting) ---
        function pointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                const intersect = ((yi > point.y) !== (yj > point.y)) &&
                    (point.x < (xj - xi) * (point.y - yi) / ((yj - yi) || 1e-10) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // --- Bounding box for a polygon ---
        function getBoundingBox(polygon) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            polygon.forEach(pt => {
                if (pt.x < minX) minX = pt.x;
                if (pt.y < minY) minY = pt.y;
                if (pt.x > maxX) maxX = pt.x;
                if (pt.y > maxY) maxY = pt.y;
            });
            return { left: minX, top: minY, right: maxX, bottom: maxY };
        }

        // Returns a random point inside the given shape (using rejection sampling).
        function randomInteriorPoint(shape) {
            const bbox = getBoundingBox(shape.vertices);
            let pt;
            do {
                pt = {
                    x: bbox.left + Math.random() * (bbox.right - bbox.left),
                    y: bbox.top + Math.random() * (bbox.bottom - bbox.top)
                };
            } while (!pointInPolygon(pt, shape.vertices));
            return pt;
        }

        // --- Intersection functions for polygons ---
        // Given a ray starting at point P with angle (in radians),
        // compute its intersection with all edges of the polygon.
        // Returns the closest intersection (if any) along with the edge index.
        function computeRayIntersectionPolygon(P, angle, shape) {
            const dx = Math.cos(angle);
            const dy = Math.sin(angle);
            let intersections = [];
            const vertices = shape.vertices;
            const n = vertices.length;
            for (let i = 0; i < n; i++) {
                const A = vertices[i];
                const B = vertices[(i + 1) % n];
                const R = { x: B.x - A.x, y: B.y - A.y };
                const denom = dx * R.y - dy * R.x;
                if (Math.abs(denom) < 1e-6) continue; // Parallel or nearly so.
                const t = ((A.x - P.x) * R.y - (A.y - P.y) * R.x) / denom;
                const u = ((A.x - P.x) * dy - (A.y - P.y) * dx) / denom;
                if (t > 1e-6 && u >= 0 && u <= 1) {
                    const point = { x: P.x + t * dx, y: P.y + t * dy };
                    intersections.push({ t, point, edgeIndex: i, u });
                }
            }
            if (intersections.length === 0) return null;
            intersections.sort((a, b) => a.t - b.t);
            return intersections[0];
        }

        // Given two intersection objects (each with an edge index),
        // return an array of the polygonâ€™s vertices between them.
        // (Works best when the polygon is convex or star-shaped.)
        function getBoundarySegment(intersect1, intersect2, shape) {
            const vertices = shape.vertices;
            const n = vertices.length;
            let segment = [];
            const startEdge = intersect1.edgeIndex;
            const endEdge = intersect2.edgeIndex;
            if (startEdge === endEdge) return segment;
            let i = (startEdge + 1) % n;
            while (i !== (endEdge + 1) % n) {
                segment.push(vertices[i]);
                i = (i + 1) % n;
            }
            return segment;
        }

        // --- Shape creation functions ---
        // Each shape is defined as an object with a "vertices" array.
        function createRectangle(x, y, width, height) {
            return {
                vertices: [
                    { x: x, y: y },
                    { x: x + width, y: y },
                    { x: x + width, y: y + height },
                    { x: x, y: y + height }
                ]
            };
        }

        // Approximates a circle as a polygon.
        function createCircle(center, radius, numSides) {
            let vertices = [];
            for (let i = 0; i < numSides; i++) {
                let angle = (i / numSides) * 2 * Math.PI;
                vertices.push({
                    x: center.x + radius * Math.cos(angle),
                    y: center.y + radius * Math.sin(angle)
                });
            }
            return { vertices: vertices };
        }

        // Star shape with alternating outer and inner radii.
        function createStar(center, outerRadius, innerRadius, numPoints) {
            let vertices = [];
            let totalPoints = numPoints * 2;
            let angleStep = (2 * Math.PI) / totalPoints;
            for (let i = 0; i < totalPoints; i++) {
                let angle = i * angleStep;
                let r = (i % 2 === 0) ? outerRadius : innerRadius;
                vertices.push({
                    x: center.x + r * Math.cos(angle),
                    y: center.y + r * Math.sin(angle)
                });
            }
            return { vertices: vertices };
        }

        // Heart shape generated from a parametric equation.
        function createHeart(center, scale, numPoints) {
            let vertices = [];
            for (let i = 0; i < numPoints; i++) {
                let t = (i / numPoints) * 2 * Math.PI;
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                vertices.push({
                    x: center.x + scale * x,
                    y: center.y - scale * y  // Flip y for canvas coordinates.
                });
            }
            return { vertices: vertices };
        }

        // --- Fracturing function for a polygon ---
        // Picks a random interior point and 4 rays, then uses the intersection points
        // (and the boundary in between) to divide the shape into 4 pieces.
        function fracturePolygon(shape) {
            const P = randomInteriorPoint(shape);
            // Generate 4 random angles.
            let angles = [];
            for (let i = 0; i < 4; i++) {
                angles.push(Math.random() * 2 * Math.PI);
            }
            angles.sort((a, b) => a - b);

            let intersections = [];
            for (let angle of angles) {
                const inter = computeRayIntersectionPolygon(P, angle, shape);
                if (inter) {
                    inter.angle = angle;
                    intersections.push(inter);
                }
            }
            if (intersections.length < 4) return [];

            let pieces = [];
            for (let i = 0; i < 4; i++) {
                let curr = intersections[i];
                let next = intersections[(i + 1) % 4];
                let boundarySegment = getBoundarySegment(curr, next, shape);
                let poly = [];
                poly.push(P);
                poly.push(curr.point);
                boundarySegment.forEach(pt => poly.push(pt));
                poly.push(next.point);
                pieces.push(poly);
            }
            return pieces;
        }

        // --- Drawing functions ---
        // Redraws the canvas using the current shape and pieces,
        // applying the current slider padding.
        function drawAll() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the original shape boundary.
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#000";
            if (currentShape) {
                drawPolygon(ctx, currentShape.vertices, "rgba(0,0,0,0)", "#000");
            }

            // Get the padding value from the slider.
            const paddingSlider = document.getElementById('paddingSlider');
            const padding = Number(paddingSlider.value);
            document.getElementById('paddingValue').textContent = padding;

            // Draw each fractured piece with the padded inset.
            currentPieces.forEach(piece => {
                const paddedPiece = shrinkPolygon(piece, padding);
                drawPolygon(ctx, paddedPiece, getRandomColor(), "#000");
            });
        }

        // Computes a new fracturing of the shape based on the dropdown selection.
        function main() {
            const shapeSelect = document.getElementById('shapeSelect');
            const shapeType = shapeSelect.value;
            switch (shapeType) {
                case "rectangle":
                    currentShape = createRectangle(100, 100, 600, 400);
                    break;
                case "circle":
                    currentShape = createCircle({ x: 400, y: 300 }, 200, 50);
                    break;
                case "star":
                    currentShape = createStar({ x: 400, y: 300 }, 250, 100, 5);
                    break;
                case "heart":
                    currentShape = createHeart({ x: 400, y: 300 }, 10, 200);
                    break;
                default:
                    currentShape = createRectangle(100, 100, 600, 400);
            }
            currentPieces = fracturePolygon(currentShape);
            drawAll();
        }

        // --- Event Listeners ---
        window.onload = function () {
            main();
            document.getElementById('fractureButton').addEventListener('click', main);
            // When the slider changes, update the drawing using the same fracturing.
            document.getElementById('paddingSlider').addEventListener('input', drawAll);
            // (Optional) Update fracturing when the shape selection changes.
            document.getElementById('shapeSelect').addEventListener('change', main);
        };
    </script>
</body>

</html>